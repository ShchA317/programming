# Лабораторная #1 #
Написать программу на языке Java, выполняющую соответствующие варианту действия. Программа должна соответствовать следующим требованиям:
1. Она должна быть упакована в исполняемый jar-архив.
2. Выражение должно вычисляться в соответствии с правилами вычисления математических выражений (должен соблюдаться порядок выполнения действий и т.д.).
3. Программа должна использовать математические функции из стандартной библиотеки Java.
4. Результат вычисления выражения должен быть выведен в стандартный поток вывода в заданном формате.

Выполнение программы необходимо продемонстрировать на сервере `helios`.


# Лабораторная #2 #
На основе базового класса `Pokemon` написать свои классы для заданных видов покемонов. Каждый вид покемона должен иметь один или два типа и стандартные базовые характеристики:
- очки здоровья (HP)
- атака (attack)
- защита (defense)
- специальная атака (special attack)
- специальная защита (special defense)
- скорость (speed)

Классы покемонов должны наследоваться в соответствии с цепочкой эволюции покемонов. На основе базовых классов PhysicalMove, SpecialMove и StatusMove реализовать свои классы для заданных видов атак. Атака должна иметь стандартные тип, силу (power) и точность (accuracy). Должны быть реализованы стандартные эффекты атаки. Назначить каждому виду покемонов атаки в соответствии с вариантом. Уровень покемона выбирается минимально необходимым для всех реализованных атак. Используя класс симуляции боя Battle, создать 2 команды покемонов (каждый покемон должен иметь имя) и запустить бой. Базовые классы и симулятор сражения находятся в [jar-архиве](https://se.ifmo.ru/documents/10180/660917/Pokemon.jar/a7ce60af-6ee6-47d0-a95e-e5ed9a697bd2). Документация в формате javadoc - [здесь](https://se.ifmo.ru/~tony/doc/). Информацию о покемонах, цепочках эволюции и атаках можно найти на сайтах http://poke-universe.ru, http://pokemondb.net, http://veekun.com/dex/pokemon

**Комментарии**

Цель работы: на простом примере разобраться с основными концепциями ООП и научиться использовать их в программах.


# Лабораторная #3 #
Описать в ООП стиле:

Дикторша продолжала улыбаться Карлсону, и он
улыбался ей в ответ. Потом он оттолкнул
Малыша в сторону: Вдруг дикторша исчезла.
Вместо нее на экране возникли два серьезных
полных господина, которые все болтали и
болтали. Карлсону это пришлось не по душе.
Он начал нажимать на все кнопки и вертеть
все ручки.


**Программа должна удовлетворять следующим требованиям:**
1. Доработанная модель должна соответствовать принципам SOLID.
2. Программа должна содержать как минимум два интерфейса и один абстрактный класс (номенклатура должна быть согласована с преподавателем).
3. В разработанных классах должны быть переопределены методы equals(), toString() и hashCode().
4. Программа должна содержать как минимум один перечисляемый тип (enum).

**Порядок выполнения работы:**
1. Доработать объектную модель приложения.
2. Перерисовать диаграмму классов в соответствии с внесёнными в модель изменениями.
3. Согласовать с преподавателем изменения, внесённые в модель.
4. Модифицировать программу в соответствии с внесёнными в модель изменениями.


# Лабораторная #4 #

Доработать программу из лабораторной работы #3, обновив реализацию объектной модели в соответствии с новой версией описания предметной области.

Описание предметной области, по которой должна быть построена объектная модель:

Он подошел вплотную к телевизору и прижался носом к носу "старика-лесовика". Потом Карлсон опустился на колени и осмотрел низ телевизора: Малыш попытался объяснить, что это не живой человек, а только изображение, но Карлсон даже рассердился: Малыш мало что знал о телевидении, но он все же очень старался объяснить Карлсону, что это такое. А кроме того, он хотел предостеречь Карлсона от грозящей ему опасности. Но Карлсон прервал его новым взрывом хохота: Малыш вздохнул. Карлсон явно ничего не понял. Малыш начал объяснять все сначала. Особым успехом эта попытка не увенчалась, но в конце концов ему все же удалось втолковать Карлсону, как удивительно действует эта штуковина. Как раз в этот момент на экране появилось личико хорошенькой дикторши. Она так приветливо улыбалась, что Карлсон широко открыл глаза. Дикторша продолжала улыбаться Карлсону, и он улыбался ей в ответ. Потом он оттолкнул Малыша в сторону: Вдруг дикторша исчезла. Вместо нее на экране возникли два серьезных полных господина, которые все болтали и болтали. Карлсону это пришлось не по душе. Он начал нажимать на все кнопки и вертеть все ручки. Он крутил ручки во все стороны, но дикторша не появлялась. Добился он только того, что полные господа стали на глазах еще больше полнеть, ноги у них сделались короткими-прекороткими, а лбы нелепо вытянулись. Эти изменения очень развеселили Карлсона -- он довольно долго забавлялся такой игрой с телевизором. А господа на экране, меняя облик, продолжали без умолку болтать, пока Карлсон им не помешал. Он с треском выключил аппарат и радостно засмеялся. Телевизор явно надоел Карлсону, он уже жаждал новых развлечений. Малыш встревожился еще больше. Если Карлсон вступит в прямую борьбу с фрекен Бок, она его непременно увидит, а именно этого не должно случиться. Пока папа и мама в отъезде, Малыш, как бы ему ни было трудно, обязан помешать этой встрече. Надо как-то напугать Карлсона, чтобы он сам старался не попадаться на глаза фрекен Бок. Малыш подумал, а потом сказал не без лукавства: Карлсон энергично замотал головой. 

# Лабораторная №5 #

Реализовать консольное приложение, которое реализует управление коллекцией объектов в интерактивном режиме. В коллекции необходимо хранить объекты класса Worker, описание которого приведено ниже.

/вариант утерян/


# Лабораторная №6 #
Разделить программу из лабораторной работы №5 на клиентский и серверный модули. 
Серверный модуль должен осуществлять выполнение команд по управлению коллекцией.
Клиентский модуль должен в интерактивном режиме считывать команды, передавать их для выполнения на сервер и выводить результаты выполнения.

Необходимо выполнить следующие требования:

    Операции обработки объектов коллекции должны быть реализованы с помощью Stream API с использованием лямбда-выражений.
    Объекты между клиентом и сервером должны передаваться в сериализованном виде.
    Клиент должен корректно обрабатывать временную недоступность сервера.
    Обмен данными между клиентом и сервером должен осуществляться по протоколу TCP
    Для обмена данными на сервере необходимо использовать сетевой канал
    Для обмена данными на клиенте необходимо использовать потоки ввода-вывода
    Сетевые каналы должны использоваться в неблокирующем режиме.

Обязанности серверного приложения:

    Работа с файлом, хранящим коллекцию.
    Управление коллекцией объектов.
    Назначение автоматически генерируемых полей объектов в коллекции.
    Ожидание подключений и запросов от клиента.
    Обработка полученных запросов (команд).
    Сохранение коллекции в файл при завершении работы приложения.
    Сохранение коллекции в файл при исполнении специальной команды, доступной только серверу (клиент такую команду отправить не может).

Серверное приложение должно состоять из следующих модулей (реализованных в виде одного или нескольких классов):

    Модуль приёма подключений.
    Модуль чтения запроса.
    Модуль обработки полученных команд.
    Модуль отправки ответов клиенту.

Сервер должен работать в однопоточном режиме.

Обязанности клиентского приложения:

    Чтение команд из консоли.
    Валидация вводимых данных.
    Сериализация введённой команды и её аргументов.
    Отправка полученной команды и её аргументов на сервер.
    Обработка ответа от сервера (вывод результата исполнения команды в консоль).
    Команду save из клиентского приложения необходимо убрать.
    Команда exit завершает работу клиентского приложения.

Важно! Команды и их аргументы должны представлять из себя объекты классов. 
Недопустим обмен "простыми" строками. Так, для команды add или её аналога необходимо сформировать объект, 
содержащий тип команды и объект, который должен храниться в вашей коллекции.

Дополнительное задание:
Реализовать логирование различных этапов работы сервера 
(начало работы, получение нового подключения, получение нового запроса, отправка ответа и т.п.) с помощью Logback


# Лабораторная №7 #

Доработать программу из лабораторной работы №6 следующим образом:
Организовать хранение коллекции в реляционной СУБД (PostgresQL). Убрать хранение коллекции в файле.
    Для генерации поля id использовать средства базы данных (sequence).
    Обновлять состояние коллекции в памяти только при успешном добавлении объекта в БД
    Все команды получения данных должны работать с коллекцией в памяти, а не в БД
    Организовать возможность регистрации и авторизации пользователей. У пользователя есть возможность указать пароль.
    Пароли при хранении хэшировать алгоритмом SHA-224
    Запретить выполнение команд не авторизованным пользователям.
    При хранении объектов сохранять информацию о пользователе, который создал этот объект.
    Пользователи должны иметь возможность просмотра всех объектов коллекции, но модифицировать могут только принадлежащие им.
    Для идентификации пользователя отправлять логин и пароль с каждым запросом.

Необходимо реализовать многопоточную обработку запросов.

    Для многопоточного чтения запросов использовать Cached thread pool
    Для многопоточной обработки полученного запроса использовать ForkJoinPool
    Для многопоточной отправки ответа использовать Fixed thread pool
    Для синхронизации доступа к коллекции использовать синхронизацию чтения и записи с помощью synchronized

Порядок выполнения работы:
    В качестве базы данных использовать PostgreSQL.
